\chapter{Application Architecture}
\label{chapter:arch}

\section[Linux Kernel Library]{Linux Kernel Library\footnote{For an extensive description of LKL see \cite{thesis}}}
\label{sec:lkl}
The linux kernel is a complex project involving many contributors and a high number of high-quality lines of code (almost 8 million lines starting with linux 2.6.34). Many attempts have been made for reusing parts of the linux kernel but due to the high coulpling of the code the time and effort necessary for decoupling it turned out to be a high discouragement. 

Linux Kernel Library is a project started by Octavian Purdil\u{a} which permits applications to use code from the linux kernel with little effort from the programmers.\textbf{LKL} can be easily integrated with a new application because it is implemented as a library and by linking it with the project one has access to the non-static linux kernel functions. The library is obtained by compiling the linux kernel(and some changes that were needed in order for this solution to work) with the needed kernel modules. 

%s-a facut portarea kernelului pt o noua arhitectura
%modif facute in afara modulului in kernel au fost triviale(pag 68)
\textbf{Linux Kernel Library} was implemented as a new architecture in the linux kernel(namely lkl architecture). This solution was chosen so that any changes necessary for LKl to work would not interfere with Linux kernel code and so integration with later kernel versions would not require too much effort. One of the most important advantages of this implementation is that LKl can easily benefit from upgrades and bug fixing in the linux kernel since no modifications were made in other parts of the kernel. 
The architecture of LKL is presented in \figref{img:lkl-arch}.
\fig[scale=0.5]{src/img/lkl.pdf}{img:lkl-arch}{LKL architecture}
Following is a short description of the architecture components:
\begin{itemize}
\item \textbf{LKL System call API} offers a interface for the applicantion to use in order to communicate with the Linux kernel, this interface is based on Linux system calls.
\item \textbf{Linux kernel} is the Linux kernel from which code will be reused by the applications. 
\item \textbf{Generic LKL Architecture} interacts with the application using native operations and a series of functions exported by LKL. These functions inform the Linux kernel of specific events. In order to port Linux on a new architecture primitives for \textit{memory management, thread support, interrupts, idle processor and time management} are needed. These primitives are implementes using native operations (e.g. for thread support and the way it is implemented in LKL native operations for creating/deleting semaphores and for up and down operations on semaphores). 
\begin{comment}
\begin{itemize}
\item \textit{Memory management mechanism} LKL has implemented a native function for memory allocation.
\item \textit{Thread support} LKL needs an implementation for kernel threads for which purpose native opperation for working with threads are required. These operations will be converted by the lkl architecture in order to work with the linux kernel. Native operations for creating/deleting semaphores and for up and down operations.
\item \textit{Interrupts}
\item \textit{Idle processor}
\item \textit{Time management} 
\end{itemize} 
\end{comment}
\item \textbf{LKL Environments} -native operations are medium-dependent; at present support for 4 environments is implemented:  POSIX, NT, NTK and APR. 
\end{itemize}
In order for a LKL application to use non-LKL resources drivers are needed. There are two types of drivers:
\begin{itemize}
\item \textbf{General driver} needed by resources required by all LKL applications. Currently two general drivers are implemented:
\begin{itemize}
\item \textbf{Console driver} responsible for printing at the console messags generated while compiling the kernel. For printing messages it uses a generic native operation named \textit{print}.
\item \textbf{Clock driver} responsible for time keeping and for generating interrupts.
\end{itemize}
\item \textbf{Application specific driver} used only by specific applications that involve resources such as ethernet interfaces, working with the disk, etc.

%\todo{read tavi's summary and thesis and write more}
\subsection{Network driver}
\label{sec:net-driver}
In order for our network application to work an application-specific driver was needed -namely a network driver-. 
The network driver is split into two separate components: a LKL component and a native one.

The LKL component takes care of the interaction with the LKL kernel. It encapsulates
and decapsulates the packets for the kernel(encapsulates them in a struct sk_buff)
and the native part.

The native component uses native syscalls to assure communication between two devices.
It can use any inter-process communication primitives like pipes, mail queues, sockets
, etc.For this implementation we have chosen to use sockets so that two devices on different computers could be connected.
The network driver was implemented at environment level and it offers an interface for creating/deleting interfaces.

The way our interface driver works is presented in \figref{img:eth-driver}
\fig[scale=0.5]{src/img/driver.pdf}{img:eth-driver}{Network driver}

\section{LKL-net}
\label{sec:lkl-net}
\textbf{\project} is a LKL application that uses the  TCP/IP stack from the Linux kernel in order to implement a series of network devices such as: hub, host, switch, router, nat, firewall. Some of these devices are implemented using already implemented functions from the Linux kernel network subsystem: 
\begin{itemize}
\item The \textbf{switch} is implemented using ioctl and bridging subsystem. 
\item The \textbf{router} is implemented using \textit{netlink interface} and routing subsystem.
\item The \textbf{nat} and \textbf{firewall} are implemented using ip_tables. 
\end{itemize} 
Besides these LKL-net devices, two additional devices were needed (non-LKL applications) for a proper functionality: a hub and a bridge device.

The architecture of LKL-net is presented in \figref{img:lkl-net}.
There are LKL and non-LKL devices as stated above and for loading and starting devices as well as facilitating communication between them, a hypervisor was implemented. For usability reasons the LKL-net application provides a command line interface and a graphical user interface.
In the next section it is presented a description of these network devices and \chapref{chapter:impl} goes into detail about both Linux kernel support and implementation aspects for the devices, hypervisor, CLI and GUI. 
%\todo{picture}
\fig[scale=0.5]{src/img/lkl-net.pdf}{img:lkl-net}{LKL-net architecture}
\section{Devices}
\label{sec:devices}
The purpose of \project was to simulate several network devices -routers, switches, firewalls, nats- , but taking into account the fact that we wanted the LKL devices to be able to communicate with non-LKL processes, we were faced with the need to implement some non-LKL devices to serve this purpose and these are hub and bridge devices.
Following is a brief description of these devices, implementation details being discussed in a separate section,  \chapref{chapter:impl}-Implementation.
\subsection{Router}
\label{sub-sec:router}
The router is the network device that connects two or more different networks. It is responsible for forwarding packets according to the routing table and its routing policies. Routes in the routing table are either static (added by the administrator) or dynamic, added using specific routing protocols such as RIP, OSPF, EIGRP, etc.
Routing decisions are taken based on IPv4 destination address. If the destination of the packet is not the router(its destination address is different from the addresses of all router's interfaces) then a search is done in the routing table starting with the most specific route in order to find a matching route for the packet and forward it accordingly. If no matching route is found then the packet is discarded. The way routing works is shown in \figref{img:routing}.
\fig[scale=0.5]{src/img/routing-process.pdf}{img:routing}{Routing Actions}
\subsection{Switch}
\label{sub-sec:switch}
The switch is a device that connects devices from the same network. Switches generally operate at data link level of the OSI model but there are network and physical layer switches as well. 

Switching decisions are based on CAM table which stores a mapping between the source MAC addresses of the arriving packet and the packet arriving interface. When a packet arrives, if its MAC address is not stored in the CAM table then it is added, and then a search is done for finding out on which interface the packet should be forwarded using as a key the destination MAC address. There is no way for storing MAC addresses in a hyerachical way in the CAM table, so that a search in the CAM table is a flat one.     
\subsection{Firewall}
\label{sub-sec:firewall}
A firewall is a network device which can block or permit incoming or outgoing traffic based on a set of filtering rules. Its purpose is to allow only authorized traffic and to block unauthorized access. When a packet arrives, a search is made in the filetring table to find a rule for that particular packet, if no rule is found then the default rule will be applied, the default rule may be to either permit or deny that packet. 

Firewalls can operate at Network or Application OSI Layer and can be implemented in either hardware or software or a combination of these two.
 
There are two types of firewalls depending on whether they store information about the connection status:
\begin{enumerate}
\item{\textbf{Stateless firewall}} watches network traffic and  allows or denies packets baed on source or destination address or other static values(such as source or destination port). It has no knowledge about traffic patterns or data flows and no mechanism for storing connection states. A stateless firewall uses simple rule-sets and there is no mechanism for detecting unwanted access (such as a response packet for a TCP connection that was not previously initiated from the inside).
\item{\textbf{Stateful firewall}} watches traffic streams and is aware of communication paths and the state in which a communication is (e.g. for TCP connection a stateful firewall is aware of the open, open sent, synchronized, synchronization acknowledge or established connection state). Stateful firewalls can implement IPsec functions such as tunneling and encryption.
\end{enumerate}
Stateless firewalls are faster than statefull firealls under intensive traffic whereas stateful firewalls can identify forged or unauthorized communication.
Choosing between which type of firewall to use should take into account the network's requirements and priorities.  
\subsection{NAT}
\label{sub-sec:nat}
Due to the rapid development of the Internet and to the address-asigning policy (full-class address spaces, almost imposible to reuse previously assigned addresses) ,IANA was faced with the threaten of address exhaustion, which lead to the decision of reserving three blocks of the IP address space for private internets\footnote{For more on Address Allocation for Private Internets see \url{http://tools.ietf.org/html/rfc1918}}:
\begin{itemize}
\item10.0.0.0        -   10.255.255.255  (10/8 prefix)
\item172.16.0.0      -   172.31.255.255  (172.16/12 prefix)
\item192.168.0.0     -   192.168.255.255 (192.168/16 prefix)
\end{itemize}
These private addresses could be used by anyone with no charge but a drawback is that they could not be routed in the internet, so that in the case a packet having a private address as its destination reaches a router, it will be discarded. A mechanism for translating these private addresses to public ones was needed.

NAT (Network address translation) is a mechanism for translating source or destination address of a packet thus enabling internet access to private networks. There are two different types of NAT:
\begin{enumerate}
\item \textbf{Basic NAT} refers to IP address translation only, NAT can change source address(SNAT) or destination address(DNAT). When using Basic NAT there is a one-to-one relation between the address being translated and the translated one so that basic NAT cannot be seen as a solution to address exhaustion.
\item \textbf{PAT} refers to both IP address and port translation, when refering to NAT one usally implies PAT.The relation between addresses being translated and the translation addresses is many-to-many or even many-to-one.
\end{enumerate}
%\todo{drawbacks-wiki}

\fig[scale=0.4]{src/img/nat.pdf}{img:nat}{PAT}
\subsection{Auxiliary devices}
\label{sub-sec:auxdev}

\subsubsection{Hub}
The hub is a physical layer network device which connects multiple network devices; when receiving a packet on a port, the hub transmits it to all the devices on all the ports except the one on which it came. When a packet is transmitted no fields of it are investigated, the hub is responsible only for retransmitting the packet without any further checking.

There are several uses of a hub: due to the way they operate, hubs are often used as repeaters; also they can be used in specific topologies where the time to forward packets is critical or if the applications would not benefit from using a switch instead of a hub. If a traffic analyzer is needed, a hub could be used as well connecting the device responsible for the investigation to the hub.
\subsubsection{Bridge}
This device is responsible for connecting two different physical mediums. In LKL it connects non-LKL processes to LKL ones so that the LKL devices are not separated from the non-LKL world.
\section{Hypervisor}
\label{sub-sec:hypervisor}
The hypervisor is a non-LKL application used to build a topology. It is also used to give devices information about other devices (e.g. the port on which a hub-given by its name- runs) or to send commands to the devices. The hypervisor can be run using the CLI or the GUI.

A image showing how the hypervisor works is \figref{img:hypervisor}. 
%\fig[scale=0.5]{src/img/arch.png}{img:hypervisor}{LKL-net Hypervisor}
\fig[scale=0.5]{src/img/hypervisor}{img:hypervisor}{LKL-net Hypervisor}
\section{Devices and features}
\begin{center}
  \begin{table}[htb]
  \begin{center}
  \begin{tabular}{ | l | l | l |}
    \hline
      Device & Medium & CLI\\ \hline
      Router & LKL & yes \\ \hline
      Switch & LKL & yes\\ \hline
      Firewall & LKL & yes\\ \hline
      NAT & LKL & yes\\ \hline
      Hub & non-LKL & no\\ \hline
      Bridge & non-LKL & no\\ 
    \hline
  \end{tabular}
  \end{center}
  \caption{LKL-net devices}
  \label{table:tdevices}
  \end{table}
\end{center}
