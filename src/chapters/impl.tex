\chapter{Implementation}
\label{chapter:impl}
In the following chapter there will be described two of the devices implemented in \project(router and NAT) as well as an auxiliary device(hub). For each of the devices the support offered by the Linux Kernel will be presented, the method chosen to implement each device and, in the end, the results of some tests which prove that the devices work as intented.

\section[Router]{Router\footnote{for more on this subject see \cite{linnetarch}}}
\label{sec:router-impl}

\subsection{Linux support}
\label{sub-sec:router-linux}

\subsubsection{Enable forwarding}
In order to configure a device to act as a router, forwarding must be enabled. If forwarding is not enabled then all packets received by the local system but not addressed to it are discarded. 
For enabling forwarding in Linux the kernel variable IP_FORWARD must be set to one. There is more than one way to probe or modify IP_FORWARD's value:
\renewcommand{\theenumi}{\alph{enumi}}
\begin{enumerate}
\item Through the ip_forward file in the /proc/sys/net/ipv4 directory. To find out or to modify IP_FORWARD's value this file can be read from or written to; also, the _sysctl() system call and the sysctl command can be used to achieve the same result 
\item Reading or writing directly the kernel variable IP_FORWARD. 
\end{enumerate}
\renewcommand{\theenumi}{\arabic{enumi}}

\subsubsection{Add/Remove interface}


\subsubsection{Route manipulation}


\subsection{\project implementation}
\label{sub-sec:router-lklnet}
\subsubsection{Enable forwarding}
We decided to enable forwarding by writing the ip_forward file. My decision was based on the fact that IP_FORWARD was hard to find, being almost concealed inside a structure. At the same time the probability that these complex structures from the network component of the kernel may change in the near future is very high. All in all enabling forwarding this way seems at present the most reliable solution.
Before writing the ip_forward file the procfs filesystem needed to be mounted in the LKL kernel. 

\subsubsection{Add/Remove interface}
   
\subsubsection{Route manipulation}
here i will cite \cite{netlinksockets}

\subsection{Device tests}
\label{sub-sec:router-tests}

Device tests

\section{NAT}
\label{sub-sec:nat-impl}

\subsection{Linux support}
\label{sub-sec:nat-linux}
The linux kernel offers a way to mangle the packets that traverse the network stack and that is through netfilter. Netfilter is a framework that provides hook handling within the Linux kernel for intercepting and manipulating network packets. IPv4 protocol has five hooks which are well-defined points in a packet's traversal of that protocol stack. At each of these points, the protocol will call the netfilter framework with the packet and the hook number.
These hooks are:
\begin{enumerate}
\item NF_IP_PRE_ROUTING located after sanity checks such as packet not truncated, IP checksum, not a promiscuous receive and before routing decisions 
\item NF_IP_LOCAL_IN after routing decisions in case the desttination for the current packet is this host
\item NF_IP_LOCAL_OUT for packets generated by local processes. 
\item NF_IP_FORWARD for packets having a different destination than this host
\item NF_IP_POST_ROUTING before outbound packets leave this host 
\end{enumerate}
These hooks translate in PREROUTING, INPUT, OUTPUT, FORWARD and POSTROUTING chains.
\fig[scale=0.5]{src/img/hooks.pdf}{img:hooks}{IPv4 Hooks}
Parts of the kernel can register to listen to the different hooks for each protocol. When a packet is passed to the netfilter framework, it checks to see if anyone has registered for that protocol and hook; if so, they each get a chance to examine (and possibly alter) the packet in order, then discard the packet (NF_DROP), allow it to pass (NF_ACCEPT), tell netfilter to forget about the packet (NF_STOLEN), or ask netfilter to queue the packet for userspace (NF_QUEUE).Then the packets that have been queued are collected (by the ip_queue driver) for sending to userspace; these packets are handled asynchronously.

A series of tables are defined in the linux kernel each of which is used for specific purposes. For each of these tables there are some predefined chains. When a packet traverses one of these chains, a search is made in the corresponding table(s) for finding matching rules and applying specified targets. Users can create new chains through iptables tool and add them to tables.
Linux kernel tables and their predefined chains are:       
\begin{itemize}
\item {\bf Nat} is used for Network Address Translation, pakets from the same stream traverse this table only once. Valid chains for this table are PREROUTING, POSTROUTING and OUTPUT. Due to the fact that only the first packet from one stream hits this table, it is not recommended to do any filtering using nat table.
\item {\bf Filter} should be used only for filtering purposes. Filtering rules may require to DROP, ACCEPT, LOG or REJECT packets for valid chains such as FORWARD, INPUT and OUTPUT.
\item {\bf Mangle} is used mainly for mangling packets; modifications may be made in packet header as well as in their data. The table consists of five built in chains, the PREROUTING, POSTROUTING, OUTPUT, INPUT and FORWARD chains. This table cannot be used for NAT purposes -DNAT, SNAT or MASQUERADE- having nat table to deal with such aspects. 
\end{itemize}

A rule from a kernel table is represented by the ipt_entry structure. The ip field of this structure having struct ipt_ip type  contains information being used to match a rule such as source or destination ip and netmask, incoming or outgoing interface name and netmask and protocol. The variable-length elems(of unsigned char type) field contains both the match and target sections for a rule. The target_offset(u_int16_t) field represents the offset in the ipt_entry structure at which the targets can be found. The next_offset field(u_int16_t) specifies the offset at which the next ipt_entry can be found.   

\subsection{\project implementation}
\label{sub-sec:nat-lklnet}
Iptables project uses the libiptc library to comunicate with netfilter. There are several functions in libiptc for adding,retrieving and modifying the rules in netfilter but the most important ones are iptc_init and iptc_commit. 
Iptc_init retrieves all the rules from the kernel for a specified table and organizes them according to the chain they belong to. The rules are returned in the xtc_handle structure. Listed below are most important parts of the TC_INIT function.

\lstset{language=C, caption=TC_INIT}
\lstinputlisting{src/code/impl/iptcinit.c}

Upon receiving a xtc_structure(through a call of the iptc_commit function), libiptc passes it to the kernel in order for any modifications made to the tables to take place.

For NAT support, we ported libiptc to LKL.

For a entry in the nat table, the iptc_entry structure must contain a target that specifies the range of addresses that are to replace the source or destination address depending on the type of NAT (SNAT or DNAT). This range of addresses is represented by the nat_nf_range structure.

\lstset{language=C, caption=struct nat_nf_range}
\lstinputlisting{src/code/impl/nfnatrange.c}

At present the LKL NAT supports only  Source Network Address Translation(SNAT) and  Destination Network Address Translation(DNAT).

In general the format of the nat command follows the same format as iptables, one difference being that instead of specifying the table with -t option, nat command assumes the table to be nat. 
\begin{description}
\item [Adding rules] \hfill \\
For adding a new rule one must specify a valid chain, the source/destination address for which to do translation or the incoming/outgoing interface name, the target -SNAT or DNAT, as well as an interval of addresses which specifies which addresses to be used as source/destination for the targeted packet.
\lstset{language=zsh,caption=Adding a rule,label=lst:saddrule}
\begin{lstlisting}
nat -A POSTROUTING -s 192.124.1.1/24 -j SNAT --to-source 10.10.10.10-10.10.10.12
nat -A PREROUTING -d 10.10.10.1 -j DNAT --to-destination 142.1.1.1
\end{lstlisting}
\item[Removing a rule] \hfill \\
The following command erases the rulenumber rule from the chain. For a chain, the rule numbering starts at 0.
\lstset{language=zsh,caption=Deleting a rule,label=lst:sdelrule}
\begin{lstlisting}
nat -D chain rulenumber
\end{lstlisting}
\item[Removing all rules] \hfill \\
Instead of just deleting one rule at a time as DELETE option does, the FLUSH option deletes al the rules from the nat table.
\lstset{language=zsh,caption=Deleting all rules,label=lst:sdelallrules}
\begin{lstlisting}
nat -F
\end{lstlisting}
\item [Listing rules] \hfill \\
One can list all the rules from the nat table with LIST option.
\lstset{language=zsh,caption=List rules,label=lst:slstrule}
\begin{lstlisting}
filter -L [chain]
\end{lstlisting}
\end{description}

\subsection{Device tests}
\label{sub-sec:nat-tests}
Linux kernel support(iptables)

My work

Device tests

\section{Hub}
\label{sec:hub:impl}

The hub is intented to work as a link between devices, it is for the LKL world what an ethernet cable is for the real world, its main purpose being to carry packets between devices.

At the same time it functions as a network hub being able to send the pachets it receives from one device to all the other devices connected to it at that moment.

Due to the fact that any two LKL devices are to be connected using a hub, the hub could capture,investigate and store packets allowing retransmission of some packets or even a replay of one scenario.  
It was implemented as a user space, non-LKL program. It uses BSD sockets for communicating with the devices and lists for storing current connections.
\fig[scale=0.5]{src/img/hub.pdf}{img:hub}{Hub}
\subsection{Device tests}
\label{sub-sec:router-tests}
About hub implementation

\section{Hypervisor}
\label{sec:hypervisor}
gtk 
cairo

\section{Configuration file and console}
\label{sec:config}
Flex
LibReadline
