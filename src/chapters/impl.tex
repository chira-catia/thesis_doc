\chapter{Implementation}
\label{chapter:impl}
In the following chapter there will be described two of the devices implemented in \project(router and NAT) as well as an auxiliary device(hub). For each of the devices the support offered by the Linux Kernel will be presented, the method chosen to implement each device and, in the end, the results of some tests which prove that the devices work as intented.

\section[Router]{Router\footnote{for more on this subject see \cite{linnetarch}}}
\label{sec:router-impl}

\subsection{Linux support}
\label{sub-sec:router-linux}

\subsubsection{Enable forwarding}
In order to configure a device to act as a router, forwarding must be enabled. If forwarding is not enabled then all packets received by the local system but not addressed to it are discarded. 
For enabling forwarding in Linux the kernel variable IP_FORWARD must be set to one. There is more than one way to probe or modify IP_FORWARD's value:
\renewcommand{\theenumi}{\alph{enumi}}
\begin{enumerate}
\item Through the ip_forward file in the /proc/sys/net/ipv4 directory. To find out or to modify IP_FORWARD's value this file can be read from or written to; also, the _sysctl() system call and the sysctl command can be used to achieve the same result 
\item Reading or writing directly the kernel variable IP_FORWARD. 
\end{enumerate}
\renewcommand{\theenumi}{\arabic{enumi}}
%removed add/remove interface because there is no support except adding new NIC

\subsubsection{Route manipulation}
After forwarding activation, the next step for configuring a router is adding routes based on which the routing decisions will be taken. Usually route selection is based on the destination address from the packet header but starting with Linux version 2.4 more routing tables are available which allow the use of other criteria for the routing process such as source address. The selection of which table to use for which packets is based in this case on a supplemental set of rules.

In the Linux kernel, routing tables are represented by rather complex data structures, which manage entries by using a number of hash tables for different prefix lengths. A easier way to comunicating with the kernel is through the Netlink interface{\footnote{See RFC3549 \url{http://tools.ietf.org/html/rfc3549}} which uses netlink sockets.
The netlink message is used to communicate between user space and kernel,each of which registeres for specific messages of interest for processing or monitoring purposes; its format is shown below:
%\begin{lstlisting}
%the message structure was here
%\end{lstlisting}
\fig[scale=0.5]{src/img/netlinkmessage.pdf}{img:netlinkmsg}{Netlink Message Structure}

The Netlink message header is generic for all services whereas IP Service Template is specific to a service and IP Service specific data is the unique data carried between the two socket ends havig a Type-Length-Value format. A thorough description of these netlink fields can be found in RFC3549 {\footnote{\url{http://tools.ietf.org/html/rfc3549}}.

Netlink address family uses the same API as the BSD sockets. In order for the communication to be possible, a call to socket system call it is needed:
\begin{lstlisting}
socket fd=socket(AF_NETLINK,SOCK_RAW,protocol);
\end{lstlisting}
where the address family and type are always AF_NETLINK and SOCK_RAW. There are several protocols that can be specified such as NETLINK_ROUTE, NETLINK_ARPD, NETLINK_FIREWALL.
Netlink sockets are connectionless and the messages are transmitted using datagrams so that the receiving of a packet cannot be guaranteed.

The NETLINK_ROUTE protocol has the largest scope from all netlink protocols and allows user space programs to modify the IPv4 routing tables as well as receive routing updates and collecting statistics. It makes use of  different message types which can be divided in separate message families that address a specific aspect of the Linux kernel network system. In general all this families contain three message types: RTM_NEW\textit{FAMILY_NAME} for adding new data, RTM_DEL\textit{FAMILY_NAME}-for deleting data and RTM_GET\textit{FAMILY_NAME} for retrieving data from the kernel.
\begin{itemize}
\item{\bf LINK} gives access to interface specific data
\item{\bf ADDR} used to manipulate network addresses on network interfaces
\item{\bf ROUTE} for managing the IPv4 route table
\item{\bf NEIGHBOURS}
\item{\bf RULES}
\item{\bf DISCIPLINES}
\item{\bf CLASSES}
\item{\bf FILTERS}
\end{itemize} 

\subsection{\project implementation}
\label{sub-sec:router-lklnet}
\subsubsection{Enable forwarding}
We decided to enable forwarding by writing the ip_forward file. My decision was based on the fact that IP_FORWARD was hard to find, being almost concealed inside a structure. At the same time the probability that these complex structures from the network component of the kernel may change in the near future is very high. All in all enabling forwarding this way seems at present the most reliable solution.
Before writing the ip_forward file the procfs filesystem needed to be mounted in the LKL kernel. 

\subsubsection{Add/Remove interface}
At any time after running the router, router interfaces can be put up (existing interfaces are by default up) or down. Also, new interfaces can be created using the following commands:
\lstset{language=zsh,caption=Adding a new interface,label=lst:saddrule}
\begin{lstlisting}
interface add <name> <MAC address> <gateway address> <port no> :create a new interface
interface address <interface name> <IPv4 address> <netmask length> : Set IP address 
\end{lstlisting}  
This is due to the existence of lkl_add_eth_tun system call which creates a new ethernet interface in the system.
 
\subsubsection[Route manipulation]{Route manipulation\footnote{A useful paper on Netlink sockets is \cite{netlinksockets}}}
At present only static rules are used in the routing process.
The route support was implemented using the Netlink Interface soecifically the ROUTE message family.
The structure that represents the netlink message header is struct nlmsghdr:
\lstset{language=C, caption=Netlink Message Header Structure}
\lstinputlisting{src/code/impl/nlmsghdr.c}
For adding or removing a route, the nlmsg_flags equals NLM_F_REQUEST|NLM_F_CREATE|NLM_F_EXCL; for adding a route nlmsg_type is RTM_NEWROUTE and for deleting a rule its value is RTM_DELROUTE.
The nlmsg_type field specifies 
The structure representing the Service Message Template is struct rtmsg:
\lstset{language=C, caption=Service Message Template Structure}
\lstinputlisting{src/code/impl/structrtmsg.c}
Both adding and removing a route target only the main table so that rtm_table must be equal to RT_TABLE_MAIN, the scope of the route is RT_SCOPE_SITE, the protocol is static and the type of the route is RTN_UNICAST.
Subsequent to filling the netlink message, a socket must be created, data transmitted to the kernel and verifying that the request was received and fulfilled, and in the end the socket must be closed.
\lstset{language=C, caption=Communicating with the kernel}
\lstinputlisting{src/code/impl/addroute.c}  

%this should appear at the end of this section
To add a new route one must specify network_address and netmask as well as the outgoing interface.
\lstset{language=zsh,caption=Adding a new interface,label=lst:saddrule}
\begin{lstlisting}
add <network_address/netmask> <interface_name> 
\end{lstlisting}  
This command calls the LKL function {\bf lkl_add_route} which uses netlink sockets for adding the new route.

%\todo{talk about sys_ioctl}
For putting router interfaces up or down and for listing the active interfaces of a router we have used \textit{ioctl} system call.

\subsection{Device tests}
\label{sub-sec:router-tests}

We built a small topology consisting of three routers that will help us tests the functions of the router. After the devices are started, static routes will be added to the routers. Two LKL applications will then be connected to routers R2 and R3 to see if there is conectivity between them. The applications are instances of a simple LKL test application used to create hosts; in order to configure a host the following must be specified: 
\begin{lstlisting}
  -a, --address=IPv4 address -IPv4 address for the lkl interface
  -n, --netmask-length=int   -IPv4 netmask length for the lkl interface
  -d, --default=IPv4 address -IPv4 default route
  -g, --gateway=IPv4 address -IPv4 gateway for lkl-the address of the system where the hub is located
  -i, --interface=string     -LKL interface name
  -m, --mac=mac address      -MAC address for the lkl interface
\end{lstlisting}

\begin{comment}
  -l, --lkl                  -means that this application uses LKL
  -p, --port=int             Port
  -r, --role=string          server/client
  -t, --to=Destination IPv4 address
                             IPv4 destination
\end{comment}
\fig[scale=0.5]{src/img/routers.png}{img:routers}{Router test}

\begin{center}
  \begin{table}[htb]
  \begin{center}
  \begin{tabular}{| l | l | l | l | l |}
    \hline
      Hostname & Interface & IP & Interface & IP \\ \hline
      R1 & eth0 & 199.9.9.9/24 & eth1 & 8.8.8.8/24 \\ \hline
      R2 & eth0 & 199.9.9.10/24 & eth1 & 10.10.10.10/24\\ \hline
      R3 & eth0 & 8.8.8.9/24 & eth1 & 168.16.21.9/24 \\
    \hline
  \end{tabular}
  \end{center}
  \caption{LKL-net devices}
  \label{table:tdevices}
  \end{table}
\end{center}

\section{NAT}
\label{sub-sec:nat-impl}

\subsection{Linux support}
\label{sub-sec:nat-linux}
The linux kernel offers a way to mangle the packets that traverse the network stack and that is through netfilter. Netfilter is a framework that provides hook handling within the Linux kernel for intercepting and manipulating network packets. IPv4 protocol has five hooks which are well-defined points in a packet's traversal of that protocol stack. At each of these points, the protocol will call the netfilter framework with the packet and the hook number.
These hooks are:
\begin{enumerate}
\item NF_IP_PRE_ROUTING located after sanity checks such as packet not truncated, IP checksum, not a promiscuous receive and before routing decisions 
\item NF_IP_LOCAL_IN after routing decisions in case the desttination for the current packet is this host
\item NF_IP_LOCAL_OUT for packets generated by local processes. 
\item NF_IP_FORWARD for packets having a different destination than this host
\item NF_IP_POST_ROUTING before outbound packets leave this host 
\end{enumerate}
These hooks translate in PREROUTING, INPUT, OUTPUT, FORWARD and POSTROUTING chains.
\fig[scale=0.5]{src/img/hooks.pdf}{img:hooks}{IPv4 Hooks}
Parts of the kernel can register to listen to the different hooks for each protocol. When a packet is passed to the netfilter framework, it checks to see if anyone has registered for that protocol and hook; if so, they each get a chance to examine (and possibly alter) the packet in order, then discard the packet (NF_DROP), allow it to pass (NF_ACCEPT), tell netfilter to forget about the packet (NF_STOLEN), or ask netfilter to queue the packet for userspace (NF_QUEUE).Then the packets that have been queued are collected (by the ip_queue driver) for sending to userspace; these packets are handled asynchronously.

A series of tables are defined in the linux kernel each of which is used for specific purposes. For each of these tables there are some predefined chains. When a packet traverses one of these chains, a search is made in the corresponding table(s) for finding matching rules and applying specified targets. Users can create new chains through iptables tool and add them to tables.
Linux kernel tables and their predefined chains are:       
\begin{itemize}
\item {\bf nat} is used for Network Address Translation, pakets from the same stream traverse this table only once. Valid chains for this table are PREROUTING, POSTROUTING and OUTPUT. Due to the fact that only the first packet from one stream hits this table, it is not recommended to do any filtering using nat table.
\item {\bf filter} should be used only for filtering purposes. Filtering rules may require to DROP, ACCEPT, LOG or REJECT packets for valid chains such as FORWARD, INPUT and OUTPUT.
\item {\bf mangle} is used mainly for mangling packets; modifications may be made in packet header as well as in their data. The table consists of five built in chains, the PREROUTING, POSTROUTING, OUTPUT, INPUT and FORWARD chains. This table cannot be used for NAT purposes -DNAT, SNAT or MASQUERADE- having nat table to deal with such aspects. 
\end{itemize}

A rule from a kernel table is represented by the ipt_entry structure. The ip field of this structure having struct ipt_ip type  contains information being used to match a rule such as source or destination ip and netmask, incoming or outgoing interface name and netmask and protocol. The variable-length elems(of unsigned char type) field contains both the match and target sections for a rule. The target_offset(u_int16_t) field represents the offset in the ipt_entry structure at which the targets can be found. The next_offset field(u_int16_t) specifies the offset at which the next ipt_entry can be found.   

\subsection{\project implementation}
\label{sub-sec:nat-lklnet}
Iptables project uses the libiptc library to comunicate with netfilter. There are several functions in libiptc for adding,retrieving and modifying the rules in netfilter but the most important ones are iptc_init and iptc_commit. 
Iptc_init retrieves all the rules from the kernel for a specified table and organizes them according to the chain they belong to. The rules are returned in the xtc_handle structure. Listed below are most important parts of the TC_INIT function.

\lstset{language=C, caption=TC_INIT}
\lstinputlisting{src/code/impl/iptcinit.c}

Upon receiving a xtc_structure(through a call of the iptc_commit function), libiptc passes it to the kernel in order for any modifications made to the tables to take place.

For NAT support, we ported libiptc to LKL.

For a entry in the nat table, the iptc_entry structure must contain a target that specifies the range of addresses that are to replace the source or destination address depending on the type of NAT (SNAT or DNAT). This range of addresses is represented by the nat_nf_range structure.

\lstset{language=C, caption=struct nat_nf_range}
\lstinputlisting{src/code/impl/nfnatrange.c}

At present the LKL NAT supports only  Source Network Address Translation(SNAT) and  Destination Network Address Translation(DNAT).

In general the format of the nat command follows the same format as iptables, one difference being that instead of specifying the table with -t option, nat command assumes the table to be nat. 
\begin{description}
\item [Adding rules] \hfill \\
For adding a new rule one must specify a valid chain, the source/destination address for which to do translation or the incoming/outgoing interface name, the target -SNAT or DNAT, as well as an interval of addresses which specifies which addresses to be used as source/destination for the targeted packet.
\lstset{language=zsh,caption=Adding a rule,label=lst:saddrule}
\begin{lstlisting}
nat -A POSTROUTING -s 192.124.1.1/24 -j SNAT --to-source 10.10.10.10-10.10.10.12
nat -A PREROUTING -d 10.10.10.1 -j DNAT --to-destination 142.1.1.1
\end{lstlisting}
\item[Removing a rule] \hfill \\
The following command erases the rulenumber rule from the chain. For a chain, the rule numbering starts at 0.
\lstset{language=zsh,caption=Deleting a rule,label=lst:sdelrule}
\begin{lstlisting}
nat -D chain rulenumber
\end{lstlisting}
\item[Removing all rules] \hfill \\
Instead of just deleting one rule at a time as DELETE option does, the FLUSH option deletes al the rules from the nat table.
\lstset{language=zsh,caption=Deleting all rules,label=lst:sdelallrules}
\begin{lstlisting}
nat -F
\end{lstlisting}
\item [Listing rules] \hfill \\
One can list all the rules from the nat table with LIST option.
\lstset{language=zsh,caption=List rules,label=lst:slstrule}
\begin{lstlisting}
filter -L [chain]
\end{lstlisting}
\end{description}

\subsection{Device tests}
\label{sub-sec:nat-tests}
NAT tests

\section{Hub}
\label{sec:hub:impl}

The hub is intented to work as a link between devices, it is for the LKL world what an ethernet cable is for the real world, its main purpose being to carry packets between devices.

At the same time it functions as a network hub being able to send the pachets it receives from one device to all the other devices connected to it at that moment.

Due to the fact that any two LKL devices are to be connected using a hub, the hub could capture,investigate and store packets allowing retransmission of some packets or even a replay of one scenario.  
It was implemented as a user space, non-LKL program. It uses BSD sockets for communicating with the devices and lists for storing current connections.
\fig[scale=0.5]{src/img/hub.pdf}{img:hub}{Hub}
\subsection{Device tests}
\label{sub-sec:router-tests}
HUB tests

\section{Configuration file and console}
\label{sec:config}

\subsubsection{Configuration file}
\label{subsec:config-file}
In order to avoid repetitive actions such as defining interfaces for a device every time it is used, each of the LKL devices has a configuration file containing important information such as: device name, device type, interface definition (interface name, IPv4 address, etc ),etc. When a device is started it reads its configuration file if one was specified for it. The configuration file is parsed using Flex. We have definded some keywords for writing a configuration file such as: hostname, ipaddress, interface, type, mac, gateway. Some of these heywords can be followed by particular values(for example valid type values are router, hub, switch). An example of a configuration file is given in \appref{ch:config-file}.

When started, a device can be passed its configuration file -if it has one- so that it is appropriately configured.
For routers and switches, the configuration file must contain the device name, the IPv4 address of the system where the device is running and a port on which the device is listening so that the hypervisor can communicate with the devices, an example is shown below:
\lstset{language=zsh,caption=Fields of Configuration File,label=lst:config-file}
\begin{lstlisting}
hostname London;
ipaddress 192.168.1.1;
port 60001;
\end{lstlisting}
Following these specification is a list of the device interfaces, for each interface one must specify the interface name, MAC address, IPv4 address, the name of the connecting hub, the gateway address. After these, other device-specific commands may follow such as definition of routes or NAT/firewall rules.

The configuration file for the hypervisor is different from that of the other devices. It starts with the keyword \textbf{hypervisor} and it must contain a list of all the devices, a new device is represented by the keyword \textbf{device}. For each of the devices its type must be specified(hub,router or switch), its name and the position when shown using the GUI(a x and a y coordinate). For a hub the port it is listening for connections is to be specified whereas for routers and switches the path to the configuration file (if the device has a configuration file) is needed.    
\lstset{language=zsh,caption=Listing a Hub in hypervisor configuration file,label=lst:hy-config-file}
\begin{lstlisting}
device {
		type hub;
		hostname hub1;
		port 50001;
		posx 350;
		posy 400;
	}
\end{lstlisting}
\lstset{language=zsh,caption=Listing a Router/Switch in hypervisor configuration file,label=lst:hy-config-file}
\begin{lstlisting}
device {
		type router/switch;
		hostname R2;
		config tests/test.router/3routers/router.R2;
		posx 200;
		posy 500;
	}
\end{lstlisting}
When run, the hypervisor reads its configuration file and starts and configures all the devices using the configuration file.
The hypervisor stores internally the devices as lists -a list for each type of device. 
The use of a semicolon at the end of line is optional.  
\subsubsection*{Console}
\label{subsubsec:impl-console}
To go even further and make the application easier to use and more user-friendly we developed a CLI for configuring devices as well as creating new ones. The command line interface was build using the Readline library\footnote{\url{http://tiswww.case.edu/php/chet/readline/rltop.html}} which provides a set of functions for creating a command line interface. At present the CLI supports command histrory as well as autocompletion. 

The command is obtained using the \textit{readline()} function, which takes as an argument a string value representing the prompt that is shown at the beginning of line. We chose to use the name of the device followed by ">" as a prompt. A command can be added to the history using the \textit{add_history()} libreadline function which takes as an argument the command that is to be added to the history.

When then TAB key is pressed all the possible commands are listed. To implement autocomplete the least required is that the \textit{rl_completion_entry_function} variable takes the value of the function that checks which of the available commands are still valid for the current command. This function iterates through all the available commands and returns the ones that match the current command. Each of the devices has its own list of available commands and so, for each of them there needs to be created a structure containing the available commands which is passed to the function responsible for autocumplete. If there is nothing typed when TAB is pressed then the list of all the available commands is shown, each of them being followed by a short description whereas if some part of the command is typed then only the matching commands will be printed, with no description.

A complete list of the available commands for all of the devices simulated using LKL is given is \appref{ch:commands}

\section{GUI}
\label{sec:gui}
Having configuration files and a means to start all the devices (using the hypervisor) makes this application easier to use but sometimes these features might not be enough, such as in the case of needing to simulate complex topologies when it is easier if one has a visual representation of the network being simulated.

In order to make LKL-Net more intuitive we built a GUI using GTK library\footnote{\url{http://www.gtk.org/}}. Using the GUI, the list of devices is available and for each device the configuration file for it can be seen, the topology can be visualised, modified or saved. It is also possible to open a new topology. When the devices are started the console associated to each of them starts as well and new commands can be typed in. The GUI allows some configuration to be made concerning the devices such as adding or removing interfaces and creating links between devices.

The topology is a new GTK widget onto which devices can be added and links be created. Drawing in this widget was possible using Cairo library.
%\fig[scale=0.5]{src/img/hypergui-1.pdf}{img:hypergui}{\project GUI}

The GUI consists of three areas:
\begin{enumerate}
\item ToolBar section
\fig[scale=0.5]{src/img/toolbar.png}{img:toolbar}{ToolBar}

This area is situated at the top of the GUI, from left to right the buttons are used for: boot devices, load topology, save topology, create router, create switch, create hub, create bridge, add link, remove link, delete device, no operation.
\item Topology area
\fig[scale=0.5]{src/img/topology-area.png}{img:top-area}{Topology Area}

This is the largest area of the GUI, here the topology is visible and changes can be done to it: devices can be added or deleted, new links between devices can be created, router or switch interfaces can be added or deleted by double ckicking on the device and entering required information.
\item Topology Devices list
\fig[scale=0.5]{src/img/gui-dev-list.png}{img:gui-dev-list}{Device List}

Situated to the right of the GUI, in this area the devices from the topology are listed; a double-click on a device name will open its configuration file (if the device has one).
\end{enumerate}

When some modification is made to a device from the GUI, the device is sent a command so the modification can take effect. Each device listens on a port for commands from the hypervisor. The port on which a device waits for commands from the hypervisor is specified in the device's configuration file.

At the same time, a device may ask the hypervisor for some information (such as the port for a hub), these requests are sent to the hypervisor on port 7200 on which the hypervisor waits for requests from devices.
%\todo{communication hypergui-devices}
